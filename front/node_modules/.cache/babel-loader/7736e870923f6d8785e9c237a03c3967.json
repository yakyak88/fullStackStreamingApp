{"ast":null,"code":"/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.2.0): util/config.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\nimport { isElement, toType } from './index';\nimport Manipulator from '../dom/manipulator';\n/**\n * Class definition\n */\n\nclass Config {\n  // Getters\n  static get Default() {\n    return {};\n  }\n\n  static get DefaultType() {\n    return {};\n  }\n\n  static get NAME() {\n    throw new Error('You have to implement the static method \"NAME\", for each component!');\n  }\n\n  _getConfig(config) {\n    config = this._mergeConfigObj(config);\n    config = this._configAfterMerge(config);\n\n    this._typeCheckConfig(config);\n\n    return config;\n  }\n\n  _configAfterMerge(config) {\n    return config;\n  }\n\n  _mergeConfigObj(config, element) {\n    const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse\n\n    return { ...this.constructor.Default,\n      ...(typeof jsonConfig === 'object' ? jsonConfig : {}),\n      ...(isElement(element) ? Manipulator.getDataAttributes(element) : {}),\n      ...(typeof config === 'object' ? config : {})\n    };\n  }\n\n  _typeCheckConfig(config) {\n    let configTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.constructor.DefaultType;\n\n    for (const property of Object.keys(configTypes)) {\n      const expectedTypes = configTypes[property];\n      const value = config[property];\n      const valueType = isElement(value) ? 'element' : toType(value);\n\n      if (!new RegExp(expectedTypes).test(valueType)) {\n        throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`);\n      }\n    }\n  }\n\n}\n\nexport default Config;","map":{"version":3,"names":["isElement","toType","Manipulator","Config","Default","DefaultType","NAME","Error","_getConfig","config","_mergeConfigObj","_configAfterMerge","_typeCheckConfig","element","jsonConfig","getDataAttribute","constructor","getDataAttributes","configTypes","property","Object","keys","expectedTypes","value","valueType","RegExp","test","TypeError","toUpperCase"],"sources":["C:/yak-projects/react/yakyakPlus/imdbstreamer/imdbstreamer/node_modules/bootstrap/js/src/util/config.js"],"sourcesContent":["/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.2.0): util/config.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nimport { isElement, toType } from './index'\nimport Manipulator from '../dom/manipulator'\n\n/**\n * Class definition\n */\n\nclass Config {\n  // Getters\n  static get Default() {\n    return {}\n  }\n\n  static get DefaultType() {\n    return {}\n  }\n\n  static get NAME() {\n    throw new Error('You have to implement the static method \"NAME\", for each component!')\n  }\n\n  _getConfig(config) {\n    config = this._mergeConfigObj(config)\n    config = this._configAfterMerge(config)\n    this._typeCheckConfig(config)\n    return config\n  }\n\n  _configAfterMerge(config) {\n    return config\n  }\n\n  _mergeConfigObj(config, element) {\n    const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {} // try to parse\n\n    return {\n      ...this.constructor.Default,\n      ...(typeof jsonConfig === 'object' ? jsonConfig : {}),\n      ...(isElement(element) ? Manipulator.getDataAttributes(element) : {}),\n      ...(typeof config === 'object' ? config : {})\n    }\n  }\n\n  _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {\n    for (const property of Object.keys(configTypes)) {\n      const expectedTypes = configTypes[property]\n      const value = config[property]\n      const valueType = isElement(value) ? 'element' : toType(value)\n\n      if (!new RegExp(expectedTypes).test(valueType)) {\n        throw new TypeError(\n          `${this.constructor.NAME.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`\n        )\n      }\n    }\n  }\n}\n\nexport default Config\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,SAAT,EAAoBC,MAApB,QAAkC,SAAlC;AACA,OAAOC,WAAP,MAAwB,oBAAxB;AAEA;AACA;AACA;;AAEA,MAAMC,MAAN,CAAa;EACX;EACkB,WAAPC,OAAO,GAAG;IACnB,OAAO,EAAP;EACD;;EAEqB,WAAXC,WAAW,GAAG;IACvB,OAAO,EAAP;EACD;;EAEc,WAAJC,IAAI,GAAG;IAChB,MAAM,IAAIC,KAAJ,CAAU,qEAAV,CAAN;EACD;;EAEDC,UAAU,CAACC,MAAD,EAAS;IACjBA,MAAM,GAAG,KAAKC,eAAL,CAAqBD,MAArB,CAAT;IACAA,MAAM,GAAG,KAAKE,iBAAL,CAAuBF,MAAvB,CAAT;;IACA,KAAKG,gBAAL,CAAsBH,MAAtB;;IACA,OAAOA,MAAP;EACD;;EAEDE,iBAAiB,CAACF,MAAD,EAAS;IACxB,OAAOA,MAAP;EACD;;EAEDC,eAAe,CAACD,MAAD,EAASI,OAAT,EAAkB;IAC/B,MAAMC,UAAU,GAAGd,SAAS,CAACa,OAAD,CAAT,GAAqBX,WAAW,CAACa,gBAAZ,CAA6BF,OAA7B,EAAsC,QAAtC,CAArB,GAAuE,EAA1F,CAD+B,CAC8D;;IAE7F,OAAO,EACL,GAAG,KAAKG,WAAL,CAAiBZ,OADf;MAEL,IAAI,OAAOU,UAAP,KAAsB,QAAtB,GAAiCA,UAAjC,GAA8C,EAAlD,CAFK;MAGL,IAAId,SAAS,CAACa,OAAD,CAAT,GAAqBX,WAAW,CAACe,iBAAZ,CAA8BJ,OAA9B,CAArB,GAA8D,EAAlE,CAHK;MAIL,IAAI,OAAOJ,MAAP,KAAkB,QAAlB,GAA6BA,MAA7B,GAAsC,EAA1C;IAJK,CAAP;EAMD;;EAEDG,gBAAgB,CAACH,MAAD,EAAqD;IAAA,IAA5CS,WAA4C,uEAA9B,KAAKF,WAAL,CAAiBX,WAAa;;IACnE,KAAK,MAAMc,QAAX,IAAuBC,MAAM,CAACC,IAAP,CAAYH,WAAZ,CAAvB,EAAiD;MAC/C,MAAMI,aAAa,GAAGJ,WAAW,CAACC,QAAD,CAAjC;MACA,MAAMI,KAAK,GAAGd,MAAM,CAACU,QAAD,CAApB;MACA,MAAMK,SAAS,GAAGxB,SAAS,CAACuB,KAAD,CAAT,GAAmB,SAAnB,GAA+BtB,MAAM,CAACsB,KAAD,CAAvD;;MAEA,IAAI,CAAC,IAAIE,MAAJ,CAAWH,aAAX,EAA0BI,IAA1B,CAA+BF,SAA/B,CAAL,EAAgD;QAC9C,MAAM,IAAIG,SAAJ,CACH,GAAE,KAAKX,WAAL,CAAiBV,IAAjB,CAAsBsB,WAAtB,EAAoC,aAAYT,QAAS,oBAAmBK,SAAU,wBAAuBF,aAAc,IAD1H,CAAN;MAGD;IACF;EACF;;AAhDU;;AAmDb,eAAenB,MAAf"},"metadata":{},"sourceType":"module"}